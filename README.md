# DIY (Do it yourself) - DI (service locator) здорового человека.

## Потому что только очень здоровый человек сможет писать столько же бойлерплейта как и для даггера

### Плюсы:

1. Compile-time safety и более. IDE сразу подчеркивает красным, если не хвтатает зависимости
2. Нет kapt = быстрая скорость сборки
3. Легко переходить с даггера
4. Можно использовать с kotlin multiplatorm
5. Гибкость

### Минусы:

1. Не отлавливает циклические зависимости при компиляции
2. Нужно писать столько же кода, как и при даггере
3. Приходится держать многое в голове (если хочешь правильно использовать)
4. Еще один di(service locator)

### В чем идея:

Если хочется на даггере ускорить сборку, то приходишь к решению, что у тебя в Мodule только Provides методы. A Component
выглядит вот так:

```
interface Component {
    val presenter: Presenter
    
    val analyst: IAnalyst 
}
```

И в каком-нибудь Fragment'е зависимости вместо @Inject получаюся через `component.presenter`.

Тогда почему бы не убрать аннотации и писать все самим. Нам потребуются интерфейсы `Component`, `Dependencies`, `Module`
и провайдить зависимости в модуле мы будем через:

1. scoped завимость просто val dep: Dep = Dep() - будет создаваться сразу при создании компонента
2. scoped зависимость через by lazy - будет создаваться только при получении
3. unscoped зависимость через val dep: Dep get() = Dep()

А вместо Qualifier у нас будет просто название зависимости.

Создавать реализации интерфейсом модулей можно как угодо. Я выбрал подход через метод create в классе-компаньоне

### Семпл приложения

В целом мой подход не настаивает на конкретном варианте хранения и менеджмента компонентов, так что можете выбрать свой
сами. Моя реализация находится в пекедже `com.example.myapplication.di`. Решение не конечное и первоначально
задумывалось под mpp, но в нем необходимость временно отпала, да и в целом нужно некоторые моменты подправить. Но в
целом все работает. Я исходил из принципа, что ComponentContainer может быть владелцем только 1 компонента
